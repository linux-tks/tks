// This code was autogenerated with `dbus-codegen-rust -r`, see https://github.com/diwic/dbus-rs
use dbus;
#[allow(unused_imports)]
use dbus::arg;
use dbus_crossroads as crossroads;
use dbus_crossroads::Context;

pub trait OrgFreedesktopSecretService {
    fn open_session(
        &mut self,
        algorithm: String,
        input: arg::Variant<Box<dyn arg::RefArg + 'static>>,
        ctx: &mut Context,
    ) -> Result<
        (
            arg::Variant<Box<dyn arg::RefArg + 'static>>,
            dbus::Path<'static>,
        ),
        dbus::MethodErr,
    >;
    fn create_collection(
        &mut self,
        properties: arg::PropMap,
        alias: String,
    ) -> Result<(dbus::Path<'static>, dbus::Path<'static>), dbus::MethodErr>;
    fn search_items(
        &mut self,
        attributes: ::std::collections::HashMap<String, String>,
    ) -> Result<(Vec<dbus::Path<'static>>, Vec<dbus::Path<'static>>), dbus::MethodErr>;
    fn unlock(
        &mut self,
        objects: Vec<dbus::Path<'static>>,
    ) -> Result<(Vec<dbus::Path<'static>>, dbus::Path<'static>), dbus::MethodErr>;
    fn lock(
        &mut self,
        objects: Vec<dbus::Path<'static>>,
    ) -> Result<(Vec<dbus::Path<'static>>, dbus::Path<'static>), dbus::MethodErr>;
    fn get_secrets(
        &mut self,
        items: Vec<dbus::Path<'static>>,
        session: dbus::Path<'static>,
        ctx: &mut Context,
    ) -> Result<
        ::std::collections::HashMap<
            dbus::Path<'static>,
            (dbus::Path<'static>, Vec<u8>, Vec<u8>, String),
        >,
        dbus::MethodErr,
    >;
    fn read_alias(&mut self, name: String) -> Result<dbus::Path<'static>, dbus::MethodErr>;
    fn set_alias(
        &mut self,
        name: String,
        collection: dbus::Path<'static>,
    ) -> Result<(), dbus::MethodErr>;
    fn collections(&self) -> Result<Vec<dbus::Path<'static>>, dbus::MethodErr>;
}

#[derive(Debug)]
pub struct OrgFreedesktopSecretServiceCollectionCreated {
    pub collection: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopSecretServiceCollectionCreated {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.collection, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSecretServiceCollectionCreated {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSecretServiceCollectionCreated {
            collection: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSecretServiceCollectionCreated {
    const NAME: &'static str = "CollectionCreated";
    const INTERFACE: &'static str = "org.freedesktop.Secret.Service";
}

#[derive(Debug)]
pub struct OrgFreedesktopSecretServiceCollectionDeleted {
    pub collection: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopSecretServiceCollectionDeleted {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.collection, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSecretServiceCollectionDeleted {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSecretServiceCollectionDeleted {
            collection: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSecretServiceCollectionDeleted {
    const NAME: &'static str = "CollectionDeleted";
    const INTERFACE: &'static str = "org.freedesktop.Secret.Service";
}

#[derive(Debug)]
pub struct OrgFreedesktopSecretServiceCollectionChanged {
    pub collection: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopSecretServiceCollectionChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.collection, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSecretServiceCollectionChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSecretServiceCollectionChanged {
            collection: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSecretServiceCollectionChanged {
    const NAME: &'static str = "CollectionChanged";
    const INTERFACE: &'static str = "org.freedesktop.Secret.Service";
}

pub fn register_org_freedesktop_secret_service<T>(
    cr: &mut crossroads::Crossroads,
) -> crossroads::IfaceToken<T>
where
    T: OrgFreedesktopSecretService + Send + 'static,
{
    cr.register("org.freedesktop.Secret.Service", |b| {
        b.signal::<(dbus::Path<'static>,), _>("CollectionCreated", ("collection",));
        b.signal::<(dbus::Path<'static>,), _>("CollectionDeleted", ("collection",));
        b.signal::<(dbus::Path<'static>,), _>("CollectionChanged", ("collection",));
        b.method(
            "OpenSession",
            ("algorithm", "input"),
            ("output", "result"),
            |ctx, t: &mut T, (algorithm, input)| t.open_session(algorithm, input, ctx),
        );
        b.method(
            "CreateCollection",
            ("properties", "alias"),
            ("collection", "prompt"),
            |_, t: &mut T, (properties, alias)| t.create_collection(properties, alias),
        )
        .annotate("org.qtproject.QtDBus.QtTypeName.In0", "QVariantMap");
        b.method(
            "SearchItems",
            ("attributes",),
            ("unlocked", "locked"),
            |_, t: &mut T, (attributes,)| t.search_items(attributes),
        )
        .annotate("org.qtproject.QtDBus.QtTypeName.In0", "StrStrMap");
        b.method(
            "Unlock",
            ("objects",),
            ("unlocked", "prompt"),
            |_, t: &mut T, (objects,)| t.unlock(objects),
        );
        b.method(
            "Lock",
            ("objects",),
            ("locked", "Prompt"),
            |_, t: &mut T, (objects,)| t.lock(objects),
        );
        b.method(
            "GetSecrets",
            ("items", "session"),
            ("secrets",),
            |ctx, t: &mut T, (items, session)| t.get_secrets(items, session, ctx).map(|x| (x,)),
        )
        .annotate(
            "org.qtproject.QtDBus.QtTypeName.Out0",
            "FreedesktopSecretMap",
        );
        b.method(
            "ReadAlias",
            ("name",),
            ("collection",),
            |_, t: &mut T, (name,)| t.read_alias(name).map(|x| (x,)),
        );
        b.method(
            "SetAlias",
            ("name", "collection"),
            (),
            |_, t: &mut T, (name, collection)| t.set_alias(name, collection),
        );
        b.property::<Vec<dbus::Path<'static>>, _>("Collections")
            .get(|_, t| t.collections());
    })
}
