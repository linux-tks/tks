// This code was autogenerated with `dbus-codegen-rust -c nonblock --file ../src/tks_dbus/fdo/org.freedesktop.Secrets.Service.xml -o service-client.rs`, see https://github.com/diwic/dbus-rs
use dbus as dbus;
#[allow(unused_imports)]
use dbus::arg;
use dbus::nonblock;

pub trait OrgFreedesktopSecretService {
    fn open_session(&self, algorithm: &str, input: arg::Variant<Box<dyn arg::RefArg>>) -> nonblock::MethodReply<(arg::Variant<Box<dyn arg::RefArg + 'static>>, dbus::Path<'static>)>;
    fn create_collection(&self, properties: arg::PropMap, alias: &str) -> nonblock::MethodReply<(dbus::Path<'static>, dbus::Path<'static>)>;
    fn search_items(&self, attributes: ::std::collections::HashMap<&str, &str>) -> nonblock::MethodReply<(Vec<dbus::Path<'static>>, Vec<dbus::Path<'static>>)>;
    fn unlock(&self, objects: Vec<dbus::Path>) -> nonblock::MethodReply<(Vec<dbus::Path<'static>>, dbus::Path<'static>)>;
    fn lock(&self, objects: Vec<dbus::Path>) -> nonblock::MethodReply<(Vec<dbus::Path<'static>>, dbus::Path<'static>)>;
    fn get_secrets(&self, items: Vec<dbus::Path>, session: dbus::Path) -> nonblock::MethodReply<::std::collections::HashMap<dbus::Path<'static>, (dbus::Path<'static>, Vec<u8>, Vec<u8>, String)>>;
    fn read_alias(&self, name: &str) -> nonblock::MethodReply<dbus::Path<'static>>;
    fn set_alias(&self, name: &str, collection: dbus::Path) -> nonblock::MethodReply<()>;
    fn collections(&self) -> nonblock::MethodReply<Vec<dbus::Path<'static>>>;
}

#[derive(Debug)]
pub struct OrgFreedesktopSecretServiceCollectionCreated {
    pub collection: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopSecretServiceCollectionCreated {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.collection, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSecretServiceCollectionCreated {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSecretServiceCollectionCreated {
            collection: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSecretServiceCollectionCreated {
    const NAME: &'static str = "CollectionCreated";
    const INTERFACE: &'static str = "org.freedesktop.Secret.Service";
}

#[derive(Debug)]
pub struct OrgFreedesktopSecretServiceCollectionDeleted {
    pub collection: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopSecretServiceCollectionDeleted {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.collection, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSecretServiceCollectionDeleted {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSecretServiceCollectionDeleted {
            collection: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSecretServiceCollectionDeleted {
    const NAME: &'static str = "CollectionDeleted";
    const INTERFACE: &'static str = "org.freedesktop.Secret.Service";
}

#[derive(Debug)]
pub struct OrgFreedesktopSecretServiceCollectionChanged {
    pub collection: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopSecretServiceCollectionChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.collection, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSecretServiceCollectionChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSecretServiceCollectionChanged {
            collection: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSecretServiceCollectionChanged {
    const NAME: &'static str = "CollectionChanged";
    const INTERFACE: &'static str = "org.freedesktop.Secret.Service";
}

impl<'a, T: nonblock::NonblockReply, C: ::std::ops::Deref<Target=T>> OrgFreedesktopSecretService for nonblock::Proxy<'a, C> {

    fn open_session(&self, algorithm: &str, input: arg::Variant<Box<dyn arg::RefArg>>) -> nonblock::MethodReply<(arg::Variant<Box<dyn arg::RefArg + 'static>>, dbus::Path<'static>)> {
        self.method_call("org.freedesktop.Secret.Service", "OpenSession", (algorithm, input, ))
    }

    fn create_collection(&self, properties: arg::PropMap, alias: &str) -> nonblock::MethodReply<(dbus::Path<'static>, dbus::Path<'static>)> {
        self.method_call("org.freedesktop.Secret.Service", "CreateCollection", (properties, alias, ))
    }

    fn search_items(&self, attributes: ::std::collections::HashMap<&str, &str>) -> nonblock::MethodReply<(Vec<dbus::Path<'static>>, Vec<dbus::Path<'static>>)> {
        self.method_call("org.freedesktop.Secret.Service", "SearchItems", (attributes, ))
    }

    fn unlock(&self, objects: Vec<dbus::Path>) -> nonblock::MethodReply<(Vec<dbus::Path<'static>>, dbus::Path<'static>)> {
        self.method_call("org.freedesktop.Secret.Service", "Unlock", (objects, ))
    }

    fn lock(&self, objects: Vec<dbus::Path>) -> nonblock::MethodReply<(Vec<dbus::Path<'static>>, dbus::Path<'static>)> {
        self.method_call("org.freedesktop.Secret.Service", "Lock", (objects, ))
    }

    fn get_secrets(&self, items: Vec<dbus::Path>, session: dbus::Path) -> nonblock::MethodReply<::std::collections::HashMap<dbus::Path<'static>, (dbus::Path<'static>, Vec<u8>, Vec<u8>, String)>> {
        self.method_call("org.freedesktop.Secret.Service", "GetSecrets", (items, session, ))
            .and_then(|r: (::std::collections::HashMap<dbus::Path<'static>, (dbus::Path<'static>, Vec<u8>, Vec<u8>, String)>, )| Ok(r.0, ))
    }

    fn read_alias(&self, name: &str) -> nonblock::MethodReply<dbus::Path<'static>> {
        self.method_call("org.freedesktop.Secret.Service", "ReadAlias", (name, ))
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn set_alias(&self, name: &str, collection: dbus::Path) -> nonblock::MethodReply<()> {
        self.method_call("org.freedesktop.Secret.Service", "SetAlias", (name, collection, ))
    }

    fn collections(&self) -> nonblock::MethodReply<Vec<dbus::Path<'static>>> {
        <Self as nonblock::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.Secret.Service", "Collections")
    }
}
